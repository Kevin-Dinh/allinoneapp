/**
 * created 08/08/2013
 * 
 * @author mbeliansky
 * @see http://livedocs.dojotoolkit.org/util/doh
 * @description unit test for module "gjax/rql/operators"
 * 
 * @generated by TemplateWizard, v.2013/01/03 //do not remove this comment please
 */
define([
	"doh",
	"gjax/testing/asserts",
	"rql/js-array-compat",
	"./_mockData",
	//tested libraries
	"gjax/rql/operators"
], function(doh, gasserts, rql, mockData) {

	var executeQuery = function(query/*, options, target*/) { // only for logging purpose
		var result = rql.query.apply(rql, arguments);
		console.log(">", query, " >>> ", result);
		return result;
	};

	var assert = {
		equal : function(real, expected, hint) { //adapter chaning order of params between node.assert and doh.is
			return doh.is(expected, real, hint);
		},
		deepEqual : function(real, expected, hint) { //not exact as node but enough for here
			return gasserts.assertArrayEquals(expected, real, hint);
		}
	};

	// this test present how to:
	//	1.	specify the fields
	//		a. to return
	//		b. to exclude
	//	2.	on arrays and subdocuments
	//		a. return part of object/array

	// there are result commented out after some queries in tests  
	// see console output for detailed result

	// helper
	function _toArray(items) {
		return items.split(",");
	}

	// executing query on array of objects
	var arrayOfObjects = mockData.complexDataArray, //
	projectionsOnArray = {
		"has" : function() {
			// has(<property>,<property>,...) - Filter objects containing named properties
			// return objects containing the whitelisted properties.

			assert.equal(executeQuery("has()", {}, arrayOfObjects).length, arrayOfObjects.length); // really?
			assert.equal(executeQuery("has(documents)", {}, arrayOfObjects).length, 2);
			assert.equal(executeQuery("has(amount,documents)", {}, arrayOfObjects).length, 1);
			assert.equal(executeQuery("has(nonExistingProperty)", {}, arrayOfObjects).length, 0);
		},
		"hasNot" : function() {
			// hasNot(<property>,<property>,...) - Filter objects not containing named properties
			// return objects not containing the whitelisted properties.

			assert.equal(executeQuery("hasNot()", {}, arrayOfObjects).length, arrayOfObjects.length); // really?
			assert.equal(executeQuery("hasNot(documents)", {}, arrayOfObjects).length, 3);
			assert.equal(executeQuery("hasNot(amount,documents)", {}, arrayOfObjects).length, 1);
			assert.equal(executeQuery("hasNot(nonExistingProperty)", {}, arrayOfObjects).length, 5);
		},
		// 1.a) specify the fields to return
		"select" : function() {
			// select(<property>,<property>,...) - Trims each object down to the set of properties defined in the arguments
			// return array of objects with defined (only existing) properties

			// select without properties
			assert.equal(executeQuery("select()", {}, arrayOfObjects).length, arrayOfObjects.length);
			// [{},{},{},{},{}]

			assert.equal(executeQuery("select(id)", {}, arrayOfObjects).length, arrayOfObjects.length);
			// [{id:1},{id:2},...]
			assert.equal(executeQuery("select(id,name)", {}, arrayOfObjects).length, arrayOfObjects.length);
			// [{id:1,name:"name1"},...]

			// if we are selecting non existing property, empty object is returned
			assert.equal(executeQuery("select(nonExistingProperty)", {}, arrayOfObjects)[0], {});
			// [{},{},{},{},{}]

			// if we are selecting existing and non existing properties, query proccess only existing props
			assert.equal(executeQuery("select(id,nonExistingProperty)", {}, arrayOfObjects).length, arrayOfObjects.length);
			// same as first -> [{id:1},{id:2},...]
		},
		"values" : function() {
			// values(<property>,<property>,...) - Returns an array of the given properties value for each object
			// return array of values or array (value can be anything) or undefined

			assert.equal(executeQuery("values(id)", {}, arrayOfObjects).length, arrayOfObjects.length);
			// [1,2,3,4,5]
			assert.equal(executeQuery("values(id,name)", {}, arrayOfObjects).length, arrayOfObjects.length);
			// [[1,"name1"],[2,"name1"],...]

			// if we are selecting non existing property, undefined value is returned
			assert.equal(executeQuery("values(nonExistingProperty)", {}, arrayOfObjects).length, arrayOfObjects.length);
			// [undefined, undefined, ...]

			// if we are selecting existing and non existing properties, undefined value is returned for non existing props
			assert.equal(executeQuery("values(id,nonExistingProperty)", {}, arrayOfObjects).length, arrayOfObjects.length);
			// [[1,undefined],[2,undefined],...]

			// return all values for each object
			assert.equal(executeQuery("values()", {}, arrayOfObjects).length, arrayOfObjects.length);
		},
		"aggregate" : function() {
			// aggregate(<property|function>,...) - Aggregates the array, grouping by objects
			// that are distinct for the provided properties, and then reduces the remaining 
			// other property values using the provided functions

			// no aggregate properties -> array with one empty object should be returned
			assert.equal(executeQuery("aggregate()", {}, arrayOfObjects)[0], {});
			// [{}]

			// aggregate() iterates throught all objects and builds temp key for each object
			// aggregates properties are presented in result
			assert.equal(executeQuery("aggregate(name)", {}, arrayOfObjects).length, 2);
			// [{name:"name1"},{name:"name2"}]

			// other aggregation, other result now
			assert.equal(executeQuery("aggregate(date,name)", {}, arrayOfObjects).length, 4);
			// [{date:"2012-01-01",name:"name1"},{date:"2012-02-01",name:"name1"},...]

			// using aggregation with max/min/sum/... functions
			assert.equal(executeQuery("aggregate(date,name,sum(amount),max(amount),min(amount))", {}, arrayOfObjects).length, 4);
			// [{0:49.26, 1:49.26, 2:49.26, date:"2012-01-01", name:"name1"}, ......... ]
			// TODO: sum/max/min result, indexed by numbers?
		},
		"limit (slice)" : function() {
			// limit(count,start,maxCount) - Returns the given range of objects from the result set
			// return array

			// limit() without args -> empty result
			assert.equal(executeQuery("limit()", {}, arrayOfObjects).length, 0);
			// []

			// return array with first element
			assert.equal(executeQuery("limit(1)", {}, arrayOfObjects)[0].id, arrayOfObjects[0].id);
			// TODO: other limit() tests
		},
		"distinct" : function() {
			// distinct() - Returns a result set with duplicates removed
			// TODO working on primitive types only
			//		use aggregate() for objects?
			assert.equal(executeQuery("distinct()", {}, _toArray("1,2,3,1,2")).length, 3);
			// [1,2,3]
		},
		"recurse" : function() {
			// recurse(<property?>) - Recursively searches, 
			// looking in children of the object as objects in arrays in the given property value

			// do not really search, but append recurse() result to target data and return it
			// on object:
			// 	target: [{id:1,address:{city:"Bratislava",zip:"12345"},...}, ..........]
			// recurse() on target
			// 	return: [{id:1,address:{city:"Bratislava",zip:"12345"},...}, {city:"Bratislava",zip:"12345"}, ..........]
			// on array:
			//  every item of array is append to result as object

			// see console for results
			// if recurse without properies is called, recursively search in every object property (object or array)
			assert.equal(executeQuery("recurse()", {}, arrayOfObjects)[1], arrayOfObjects[0].address);

			// search recursively only on documents
			// second item of result is first document in documents in first item
			assert.equal(executeQuery("recurse(documents)", {}, arrayOfObjects)[1], arrayOfObjects[0].documents[0]);

			// no array present in result, except first item (target data)
			// all returned result from recurse() is object
		},
		// 1.b) specify the fields to exclude
		"unselect" : function() {
			// unselect(<property>,<property>,...) - Remove from each object the set of properties defined in the arguments
			// return array of objects without defined properties

			// unselect without properties
			assert.equal(executeQuery("unselect()", {}, arrayOfObjects).length, arrayOfObjects.length);
			// return unmodified target

			assert.equal(executeQuery("unselect(id)", {}, arrayOfObjects).length, arrayOfObjects.length);
			// target has not id property anymore
			assert.equal(executeQuery("unselect(id,name)", {}, arrayOfObjects).length, arrayOfObjects.length);
			// target has not id and name property anymore

			// if we are unselecting non existing property, unmodified target is returned
			assert.equal(executeQuery("unselect(nonExistingProperty)", {}, arrayOfObjects).length, arrayOfObjects.length);
			// return unmodified target

			// if we are unselecting existing and non existing properties, query proccess only existing props
			assert.equal(executeQuery("unselect(id,nonExistingProperty)", {}, arrayOfObjects).length, arrayOfObjects.length);
			// return target has not id property anymore, other props should not be missing
		}
	};

	doh.register("gjax/rql/operators#projections-array", projectionsOnArray);

	// TODO executing query on object
	var object = mockData.complexDataObject, //
	projectionsOnObject = {
		// 1.a) specify the fields to return
		"pick" : function() {
			// pick(<property>,<property>,...) - Trims object down to the set of properties defined in the arguments
			// return object with defined (only existing) properties
			assert.equal(executeQuery("pick(name)", {}, object).name, object.name);
			assert.equal(typeof executeQuery("pick(name)", {}, object).id, "undefined");
			// {name: "name1"}

			assert.equal(executeQuery("pick(documents)", {}, object).documents.length, 3);
			// {documents: [{...},{...},{...}]}

			// if we are selecting non existing property, empty object is returned
			assert.equal(executeQuery("pick(nonExistingProperty)", {}, object), {});
			// {}

			// if we are selecting existing and non existing properties, query proccess only existing props
			assert.equal(executeQuery("pick(id,nonExistingProperty)", {}, object).id, object.id);
			// {id:1}
		},
		"values" : function() {
			// similar to projectionsOnArray.values()
			// implementation of values() improved to working with object, see [2]
			assert.equal(executeQuery("values()", {}, object).length, 7);
			assert.equal(executeQuery("values(name)", {}, object)[0], object.name);
			assert.equal(executeQuery("values(id,name)", {}, object).length, 2);
			assert.equal(executeQuery("values(id,name)", {}, object)[0], object.id);
			assert.equal(executeQuery("values(id,name)", {}, object)[1], object.name);
		},
		"recurse" : function() {
			// recurse(<property?>) - Recursively searches, 
			// looking in children of the object as objects in arrays in the given property value

			// similar to projectionsOnArray.recurse()
			// recurse() works on array and object too

			// see console for results
			// if recurse without properies is called, recursively search in every object property (object or array)
			assert.equal(executeQuery("recurse()", {}, object)[1], object.address);

			// search recursively only on documents
			// second item of result is first document in object.documents
			assert.equal(executeQuery("recurse(documents)", {}, object)[1], object.documents[0]);

			// no array present in result, except first item (target data)
			// all returned result from recurse() is object
		},
		// 1.b) specify the fields to exclude
		"omit" : function() {
			// omit(<property>,<property>,...) - Remove each object the set of properties defined in the arguments
			// return object without defined properties

			// unselect without properties
			assert.equal(executeQuery("omit()", {}, object).id, object.id);
			// return unmodified object

			assert.equal(typeof executeQuery("omit(id)", {}, object).id, "undefined");
			// object has not id property anymore
			assert.equal(typeof executeQuery("omit(id,name)", {}, object).name, "undefined");
			// object has not id and name property anymore

			// if we are unselecting non existing property, unmodified object is returned
			executeQuery("omit(nonExistingProperty)", {}, object);
			// return unmodified object

			// if we are unselecting existing and non existing properties, query proccess only existing props
			assert.equal(typeof executeQuery("omit(id,nonExistingProperty)", {}, object).id, "undefined");
			// return object has not id property anymore, other props should not be missing
		}
	};

	doh.register("gjax/rql/operators#projections-object", projectionsOnObject);

	// pack evaluateProperty function
	//var evaluatePropertyOriginal = rql.evaluateProperty;
	//rql.evaluateProperty = function(object, property) {
	//	var result = evaluatePropertyOriginal(object, property); // no scope needed
	//	console.log(">", "evaluateProperty(object,", property, ")", " >>> ", result);
	//	return result;
	//};

	var projectionsOnNestedProperties = {
		"evaluate property" : function() {
			// understanding properties evaluation
			// evaluateProperty is used for searching and proccessing for object properties and theirs values

			assert.equal(rql.evaluateProperty(object, "id"), 1);
			assert.equal(rql.evaluateProperty(object, _toArray("address,city")), "Bratislava");
			assert.equal(typeof rql.evaluateProperty(object, _toArray("address,nonExistingProperty")), "undefined");
			assert.equal(typeof rql.evaluateProperty(object, "nonExistingProperty"), "undefined");

			// TODO: missing check for non existing nested properties
			//assert.equal(typeof rql.evaluateProperty(object, _toArray("nonExistProp1,nonExistProp2")), "undefined");
		},
		// TODO add more projections on nested props
		"select" : function() {
			// js-array-compat will translate select(address/city) as
			// 		return op('select').call(this, ["address", "city"])
			// js-array-compat will translate select(id,address/city) as
			//	 	return op('select').call(this, "id",["address","city"])

			assert.equal(executeQuery("select(address/city)", {}, arrayOfObjects).length, arrayOfObjects.length);
			// [{address:{city:"Bratislava"}},{address:{city:"Bratislava"}},...]

			assert.equal(executeQuery("select(id,address/city)", {}, arrayOfObjects)[0].address.city, arrayOfObjects[0].address.city);
			// [{id:1,address:{city:"Bratislava"}},{id:2,address:{city:"Bratislava"}},...]

			assert.equal(executeQuery("select(address/nonExistingProperty)", {}, arrayOfObjects).length, arrayOfObjects.length);
			// [{"address": {}},{"address": {}},{"address": {}},...]

			// TODO: missing check for non existing nested properties
			//assert.equal(executeQuery("select(nonExistProp1/nonExistProp2)", {}, arrayOfObjects).length, arrayOfObjects.length);
		},
		"unselect" : function() {
			assert.equal(executeQuery("unselect(address/zip)", {}, arrayOfObjects).length, arrayOfObjects.length);
			assert.equal(executeQuery("unselect(id,address/zip)", {}, arrayOfObjects).length, arrayOfObjects.length);
			assert.equal(executeQuery("unselect(name,address/zip,address/city)", {}, arrayOfObjects).length, arrayOfObjects.length);
			// TODO: do not work on array values
			//executeQuery("unselect(documents/address/city)", {}, arrayOfObjects);
		},
		"values - array" : function() {
			// getting values of nested properties from array of objects
			// can be done by following query combination:
			//		select([<property?><nested_property?>]+)&values()

			assert.equal(executeQuery("selectOrig(id,address/city)&values()", {}, arrayOfObjects).length, arrayOfObjects.length);
			// [[1,"Bratislava"],[2,"Bratislava"]...]
			assert.equal(executeQuery("selectOrig(address/zip,address/city)&values()", {}, arrayOfObjects).length, arrayOfObjects.length);
			// [[12345,"Bratislava"],[12345,"Bratislava"],...]
			assert.equal(executeQuery("selectOrig(id,address/zip,date,address/city)&values()", {}, arrayOfObjects).length, arrayOfObjects.length);
			// [[1,12345,"2012-01-01","Bratislava"],...]
			assert.equal(executeQuery("selectOrig(address/city)&values()", {}, arrayOfObjects).length, arrayOfObjects.length);
			// [["Bratislava"],["Bratislava"],...]
			assert.equal(executeQuery("selectOrig(address/city)&values(address/city)", {}, arrayOfObjects).length, arrayOfObjects.length);
			// ["Bratislava","Bratislava",....]
		},
		"pick" : function() {
			assert.equal(executeQuery("pick(address/zip)", {}, object).address.zip, object.address.zip);
			// {address:{zip:"12345"}}

			// combination of properties
			assert.equal(executeQuery("pick(id,address/city)", {}, object).address.city, object.address.city);
			// {id:1, address:{city:"Bratislava"}}

			assert.equal(typeof executeQuery("pick(address/nonExistingProperty)", {}, object).address.nonExistingProperty, "undefined");
			// {address:{nonExistingProperty:undefined}}

			// TODO: missing check for non existing nested properties
			//executeQuery("pick(nonExistProp1/nonExistProp2)", {}, object);
		},
		"values - object" : function() {
			// getting values of nested properties from object
			// can be done by following query combination:
			//		pick([<property?><nested_property?>]+)&values()

			// TODO: need values([<property?><nested_property?>]+) implementation on object/nested values?
			//executeQuery("pick(id,address/city)&values()", {}, object);
			//executeQuery("pick(id,address/zip,date,address/city)&values()", {}, object);
			//executeQuery("pick(address/city)&values(address)", {}, object);
			executeQuery("pick(address/city)&values(address)&values(city)", {}, object);
			// ["Bratislava"]
		},
		"omit" : function() {
			var result = executeQuery("omit(address/city,address/zip)", {}, object);
			assert.equal(typeof result.address.city, "undefined");
			assert.equal(typeof result.address.zip, "undefined");
			assert.equal(result.address, {});

			result = executeQuery("omit(id,address/city,name)", {}, object);
			assert.equal(result.date, object.date);
			assert.equal(result.address.zip, object.address.zip);
			assert.equal(typeof result.id, "undefined");
			assert.equal(typeof result.address.city, "undefined");
		}
	};

	doh.register("gjax/rql/operators#projections-nested-properties", projectionsOnNestedProperties);

	// set custom templates
	rql.templates = { // [3] TODO include operators in template
		convertToPartner : { // used in project operator test
			status : 1,
			partId : "$id",
			partName : "$name",
			city : "$address/city",
			eff : {
				from : "$date",
				to : "9999-12-31"
			}
		},
		documentList : { // used in call operator test
			documentId : "$id",
			documentCode : "$documents",
			amount : "$amount",
			date : "$date",
			city : "$address/city",
			zip : "$address/zip"
		}
	};

	var projectionsOther = {
		"recurse2" : function() {
			// recurse2(<property?>,<removeOriginals>) - Same as recurse(), but can remove originals data

			// picks recursively only documents, returns documents only
			assert.equal(executeQuery("recurse2(documents,1)", {}, object).length, object.documents.length);

			var l = arrayOfObjects[0].documents.length + arrayOfObjects[2].documents.length;
			assert.equal(executeQuery("recurse2(documents,1)", {}, arrayOfObjects).length, l);
		},
		"project" : function() {
			// project(<template_name>) - Project actual data set to new format, see 'uniqTmplName' template [3]
			//		works on array or object
			var d = executeQuery("project(convertToPartner)", {}, object);
			assert.equal(d.partId === 1 && d.partName === object.name && d.status === 1 && //
			d.city === object.address.city && d.eff && d.eff.from === object.date & d.eff.to === "9999-12-31", true,
					"One of the projected properties was not resolve correctly.");
		},
		"reverse" : function() {
			//		works on array or object
			var data = {
				"id" : 1,
				"bar" : {
					"foo" : 10
				},
				"a" : [
					{
						"x" : "y"
					},
					{
						"x" : "c"
					}
				]
			};
			var d = executeQuery("reverse()", {}, data), //
			assertMsg = "One of the reversed properties was not resolve correctly.";

			// properties, TODO: as doh.is
			assert.equal("1" in d, true, assertMsg);
			assert.equal("bar" in d, true, assertMsg);
			assert.equal("10" in d.bar, true, assertMsg);
			assert.equal(d.a instanceof Array, true, assertMsg);
			assert.equal("y" in d.a[0], true, assertMsg);
			// values
			assert.equal(d["1"] === "id", true, assertMsg);
			assert.equal(d.bar["10"] === "foo", true, assertMsg);
			assert.equal(d.a[0].y === "x", true, assertMsg);
		},
		"unwind" : function() {
			// unwind(<property>,<newPropertyName?>) - transform data into root object defined in 'property' to "flat"
			//		works on array or object
			assert.equal(executeQuery("unwind(documents)", {}, object).length, object.documents.length);

			// unwinded objects are included twice
			var l = arrayOfObjects.length + arrayOfObjects[0].documents.length + arrayOfObjects[2].documents.length - 2;
			assert.equal(executeQuery("unwind(documents)", {}, arrayOfObjects).length, l);

			var r = executeQuery("unwind(documents,docs)", {}, arrayOfObjects);
			assert.equal("docs" in r[0], true, "Docs property should be included in result.");
			assert.equal(r.length, l);

			// rename property
			var data = {
				partnerName : "name1",
				addressesId : [
					2,
					3,
					4,
					5
				]
			};
			assert.equal(executeQuery("unwind(addressesId,addressId)", {}, data).length, data.addressesId.length);
		},
		"call" : function() {
			// call(<property>,<operator>,...) - run operators on value of first-level object property
			// value should be instance of array
			// does not modify object structure (returns original), only property value should be modified

			// test various syntax
			assert.equal(executeQuery("call(documents,amount<=20,amount>=13)", {}, object).documents.length, 1);
			assert.equal(executeQuery("call(documents,le(amount,20),ge(amount,13))", {}, object).documents.length, 1);
			assert.equal(executeQuery("call(documents,(amount<=20&amount>=13))", {}, object).documents.length, 1);
			assert.equal(executeQuery("call(documents,(le(amount,20)&ge(amount,13)))", {}, object).documents.length, 1);
			assert.equal(executeQuery("call(documents,and(amount<=20,amount>=13))", {}, object).documents.length, 1);
			assert.equal(executeQuery("call(documents,and(le(amount,20),ge(amount,13)))", {}, object).documents.length, 1);

			// apply other projection operators for all item of documents array

			// documents will have date only (like expand with condition)
			assert.equal(executeQuery("call(documents,select(date))", {}, object).documents.length, 3);
			// documents will have array of document codes as documents property (like expandid)
			assert.equal(executeQuery("call(documents,values(code))", {}, object).documents.length, 3);

			// complex sample, check console for result
			executeQuery("call(documents,le(amount,20),values(code))&unwind(documents)&project(documentList)", {}, object);
		},
		"join" : function() {
			// join(<property>[,<joinWith>])
			assert.equal(executeQuery("join(test)", {}, {
				test : [
					1,
					2,
					3
				]
			}).test, "1,2,3");

			assert.equal(executeQuery("join()", {}, [
				[
					1,
					2
				],
				[
					2,
					3
				]
			]), [
				"1,2",
				"2,3"
			]);
		},
		"remapValue" : function() {
			// remap(<valueToFind>,<valueToReplace>)
			// only primitive types
			var testObj = {
				a : "a",
				b : "b",
				c : null
			};
			var r = executeQuery("remapValue(a,b)", {}, testObj);
			assert.equal(r.a, "b");
			assert.equal(r.b, "b");

			r = executeQuery("remapValue(b,a)", {}, testObj);
			assert.equal(r.a, "a");
			assert.equal(r.b, "a");

			r = executeQuery("remapValue(null,a)", {}, testObj);
			assert.equal(r.c, "a");

			r = executeQuery("remapValue(null,string:)", {}, testObj);
			assert.equal(r.c, "");
		}
	};

	doh.register("gjax/rql/operators#projections-other", projectionsOther);
});
