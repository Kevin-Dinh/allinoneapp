/**
 * created 08/24/2015
 * 
 * @author marcus
 * @see http://livedocs.dojotoolkit.org/util/doh
 * @description TODO: fill in description
 * 
 * @generated by TemplateWizard, v.2015/07/16 //do not remove this comment please
 */
define([
	"doh",
	"dojo/has",

	// tested libraries
	"gjax/lang/array/arrayfy",
	"dojo/_base/lang",
	"dojo/json",
	"dojox/lang/functional"
], function(doh, has, arrayfy, lang, json, df) {

	function identity(a) { // helper
		return a;
	}

	var testLib = {
		"has('es5-array-forEach') exists" : function() {
			//  is defined by module, and has true or false value, based on browser and config
			doh.t(has("es5-array-forEach") != null);
			doh.t(has("es5-array-forEach") === true || has("es5-array-forEach") === false);
		},
		"arrayfy is function" : function() {
			doh.t(typeof arrayfy === 'function');
		},
		"arrayfy has dojo and identity implementations (functions)" : function() {
			doh.t(typeof arrayfy.dojo === 'function');
			doh.t(typeof arrayfy.identity === 'function');
		},
		"one of them is returned as arrayfy" : function() {
			doh.t(arrayfy === arrayfy.dojo || arrayfy === arrayfy.identity);
		}
	};

	function testCommon(arrayfy) { //unroll for specific implementation
		// common tests to be runnable with both native arrays (arrayfy.identity) and arrayfy.dojo arrays
		return {
			"arr.filter exists on array" : function() {
				doh.is("function", typeof arrayfy([]).filter);
			},
			"result of arrayfy([]) is array" : function() {
				doh.t(arrayfy([]) instanceof Array);
			},
			"result of arrayfy([]).filter is array" : function() {
				doh.t(arrayfy([]).filter(identity) instanceof Array);
			},
			"result of arrayfy([]).filter is lang.isArray" : function() {
				doh.t(lang.isArray(arrayfy([]).filter(identity)));
			},
			"result of arrayfy([]).filter is array with filter method (chainable)" : function() {
				doh.is("function", typeof arrayfy([]).filter(identity).filter);
			},
			"arrayfy([]).filter takes context as 2nd param" : function() {
				var called;
				doh.t(arrayfy([
					1
				]).filter(function() {
					doh.is("asdf", this);
					called = true;
				}, "asdf"));
				doh.t(called);
			},
			"chainable" : function() {
				arrayfy([]).map(identity).filter(identity).forEach(identity);
			},
			"sample map and filter test" : function() {
				// naive, i believe all works, code is too simple
				// just some random transformations chaining
				var r = arrayfy([
					0,
					1,
					2,
					3
				]).map(function(item, index, arr) {
					return {
						item : item,
						index : index,
						arr : arr
					};
				}).filter(function(item /*, index, arr*/) {
					return item.item < 3;
				}).map(function(item) {
					return item.item;
				});
				doh.t(r instanceof Array);

				doh.is([
					0,
					1,
					2
				], r);
			},
			"result of arrayfy([]).reduce is chainable (when result is array)" : function() {
				doh.is("function", typeof arrayfy([]).reduce(identity, []).reduce);
			},
			"result of arrayfy([]).reduce is not chainable (when result is not array)" : function() {
				doh.isNot("function", typeof arrayfy([]).reduce(identity, {}).reduce);
			},
			"arrayfy([]).reduce DOES NOT take context as 2nd/3rd param" : function() {
				var called = 0;
				arrayfy([
					1
				]).reduce(function() {
					doh.isNot("abc", this);
					called++;
				}, "abc");

				arrayfy([
					1
				]).reduce(function() {
					doh.isNot("abc", this);
					called++;
				}, 0, "abc");

				doh.is(2, called);
			},
			"simple reduce test" : function() {
				var r = arrayfy([
					1,
					2,
					3,
					4,
					5,
					6,
					7
				]).reduce(function(prev, item/*, index, arr*/) {
					// simple test: result will contain only prime numbers
					if (item != 1 && prev.every(function(n) {
						return item % n !== 0;
					})) {
						prev.push(item);
					}
					return prev;
				}, []);
				doh.t(r instanceof Array);
				doh.is([
					2,
					3,
					5,
					7
				], r);
			},
			"reduce test with initialValue uses that as 'prev' in 1st iteration" : function() {
				var r = arrayfy([
					0,
					1,
					2
				]).reduce(function(prev/*, item, index, arr*/) {
					return prev + 1;
				}, 100);
				doh.is(103, r);
			},
			"reduce without initialValue uses 1st item as 'prev' in 1st iteration" : function() {
				var r = arrayfy([
					7,
					1,
					2
				]).reduce(function(prev/*, item, index, arr*/) {
					return prev + 1;
				});
				doh.is(9, r);
			},
			"serializations" : function() {
				var extendedArray = arrayfy([
					1
				]);
				var r = json.stringify(extendedArray);
				// regardless of implementation, 
				// in native hasOwnProperty is true, in non native it is false 
				// functions do not serialize
				doh.is("[1]", r, "serialized form is ok");
			},
			"Can use Lambdas as callbacks (USE THIS, not dojo/array String signatures)" : function() {
				var r = arrayfy([
					1,
					2,
					3
				]).map(df.lambda("item*2"));
				doh.is([
					2,
					4,
					6
				], r);
			}
		};
	}

	var extras = {
		"arrayfy.dojo - you can use String as callback (DONT'T USE THIS, use lambdas instead)" : function() {
			// this is discouraged since:
			// map, filter has different syntax of "strings" as reduce (see array.js v fold.js)
			var r = arrayfy.dojo([
				1,
				2,
				3
			]).map("return item*2");
			doh.is([
				2,
				4,
				6
			], r);
		}
	};
//	function isNative(fn) {
//		return (/\{\s*\[native code\]\s*\}/).test('' + fn);
//	}

	doh.register("arrayfy", testLib);
	doh.register("arrayfy-dojo", testCommon(arrayfy.dojo));
	doh.register("arrayfy-identity", testCommon(arrayfy.identity));
	doh.register("arrayfy-extras", extras);

	// runnable with: node (dnode)
	has("host-browser") || doh.run();

});
