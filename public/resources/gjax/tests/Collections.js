/**
 * created 10/09/2012
 * 
 * @author jukrop
 * @see http://livedocs.dojotoolkit.org/util/doh
 * @description test for gjax/Collections
 * 
 * @generated by TemplateWizard, v.2012/10/01 //do not remove this comment please
 */
define([
	"dojo/_base/lang",
	"doh",
	//tested libraries
	"gjax/Collections"
], function(lang, doh, collectionUtils) {
	
	// please do not format this file!

	// private functions
	function getTest(fncName, data) {
		return function() {
			for ( var i = 0; i < data.length; i += 3) {
				var input = data[i], expected = data[i + 1], output,
					postCheck = data[i + 2],
					inputCopy = lang.clone(input);
				try {
					output = collectionUtils[fncName].apply(collectionUtils, input);
				} catch (e) {
					output = e.message;
				}
				doh.is(expected, output, "Original input: " + inputCopy);
				
				// 
				if (postCheck) {
					// we may require that original input is
					// - not changed after operation (invariant)
					// - changed and equal to output
					// - changed and equal to some value
					var expectedInputValue = postCheck === "in" ? inputCopy[0] : postCheck === "out" ? output : postCheck;
					doh.is(expectedInputValue, input[0], "Postcheck broken!");
				}
			}
		};
	}
	
	var arr = ["a",2,3];
	var sparse = [];
	sparse[2] = 1;
	
	// structure [inputs], output, "in"|"out"|any
	// third parameter is used for post check
	// - "in" - original input must equal current value of input (i.e. input was not modifed)
	// - "out" - original input must equal return value (i.e. some inplace operation was done)
	// - other - original input must equal other value (i.e. some inplace operation was done, but something else was returned)
	var testData = {
		"removeAll" : [
			[["a", "b", "c"],["b", "c" ]], ["a"], "in",
			[["a", "b", "c"],["b", "c", "a"]], [], "in",
			[["a", "b", "c"],["d", "e"]], ["a", "b", "c"], "in",
			[["a", "b", "c"],["b", "c", "d", "e"]], ["a"], "in"
		],
		"retainAll" : [
			[["a", "b", "c"],["b", "c" ]], ["b", "c"], "in",
			[["a", "b", "c"],["b", "c", "a"]], ["a", "b", "c"], "in",
			[["a", "b", "c"],["d", "e"]], [], "in",
			[["a", "b", "c"],["b", "c", "d", "e"]], ["b", "c"], "in"
        ],
        "unique" : [
			[["a", "b", "b", "c", "d", "c", "b", "c"]], ["a", "b", "c", "d"], "in",
			[["a", "b", "c", "d"]], ["a", "b", "c", "d"], "in",
			[["0", 1, "2", 0, 0, 1, "1"]], ["0", 1, "2", 0, "1"], "in",
			[[{a : 1}, {a : 1, b : 2}, {a : 2, b : 1}, {a : 2}], "a"], [{a : 1}, {a : 2, b : 1}], "in",
			[[{a : 1}, {b : 1}, {c : 1}, {d : 1}], "a"], [{a : 1}, {b : 1}], "in"
		],
		"compact" : [
			[[null, "a", null, null, "b", null, null, null]], ["a", "b"], "in",
			[[null, null, null, null, null]], [], "in",
			[new Array(3)], [], "in"
		],
		"removeAt" : [
			[["a", "b", "c", "d"], 0], ["a"], ["b", "c", "d"],	// remove first
			[["a", "b", "c", "d"], 1], ["b"], ["a", "c", "d"],	// remove middle
			[["a", "b", "c", "d"], 3], ["d"], ["a", "b", "c"],	// remove last
			[["a", "b", "c", "d"], 10], [], "in"				// remove out of bounds
		],
		"sort" : [
			[[{order : 3, id : "3"}, {order : 1, id : "1"}, {order : 2, id : "2"}], "order", false], // sort ascending by property
				[{order : 1, id : "1"}, {order : 2, id : "2"}, {order : 3, id : "3"}], "out",
			[[{order : 3, id : "3"}, {order : 1, id : "1"}, {order : 2, id : "2"}], "order", true],  // sort descending by property
				[{order : 3, id : "3"}, {order : 2, id : "2"}, {order : 1, id : "1"}], "out",
			[[4, 1, 3]], [1, 3, 4], "out", 				// sort ascending by value
			[[4, 1, 3], "foo"], [4, 1, 3], "out" 		// sort ascending by nonexistent property
		],
		"equals" : [
			[arr, arr], true, "in",
			[["a", 2, 3], ["a", 2, 3]], true, "in",
			[[2, "a", 3], ["a", 2, 3]], false, "in",
			[["a", 2, 3, undefined], ["a", 2, 3]], false, "in",
			[[1, 2], "1,2"], false, "in",
			[[1, 2], [[1, 2]]], false, "in",
			[[], []], true, "in",
			[[NaN], [NaN]], true, "in",
			[new Array(0), []], true, "in"
//			[[{}], [{}]], false, "in"
//			[sparse, [undefined, undefined, 1]], true, "in" // invariant check would fail here bacause lang.clone cannot properly clone sparse arrays...
			// TODO report that to dojo
			
			// TODO more equals tests..
		]
	};
	
	
	var tests = {};
	for (var fncName in testData) {
		tests[fncName + "Test"] = getTest(fncName, testData[fncName]);
	}
	
	//------------
	var bugsAndFixes={
		"true for different string arrays:":function(){
			//shall return false of course but used to return true
			doh.f(collectionUtils.equals(["a"],["b"]), "fixed 2012/12/06"); 
		}	
	};
	doh.register("gjax/Collections", tests);	
	doh.register("gjax/Collections-bugsAndFixes", bugsAndFixes);	

});
