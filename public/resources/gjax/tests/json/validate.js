/**
 * created 04/22/2013
 * 
 * @author arakovsky
 * 
 * @description test for module json/json-schema/lib/validate2 (jasn validation)
 * 
 * @generated by TemplateWizard, v.2012/11/21 //do not remove this comment please
 * @see http://livedocs.dojotoolkit.org/util/doh
 */
define([
	"require",
	"module",
	"dojo/ready",
	"dojo/_base/array",
	"doh",
	"json/json-schema/lib/validate2",
	"dojo/text!./_data/_basic.schema.json",
	"dojo/text!./_data/_detail.schema.json",
	"dojo/text!./_data/_mixed.schema.json",
	"dojo/text!./_data/_partner.get.schema.json",
	"dojo/text!./_data/_typeOrNull.schema.json",
	"dojo/text!json/json-schema/draft-03/schema.json",
	"dojo/json",
	"gjax/request/jsonRefXhr",
	"./_data/_partner.get.sample",
	"dojo/date/stamp",
	"gjax/uri/Uri"
], function(require, module, ready, array, doh, validate, basicSchemaJson, detailSchemaJson, mixedSchemaJson, partnerSchemaJson, //
typeOrNullSchemaJson, v3SchemaJson, json, jsonRefXhr, partnerData, stamp, Uri) {

	var detailSchema = json.parse(detailSchemaJson/*, secure*/);
	var basicSchema = json.parse(basicSchemaJson/*, secure*/);
	var partnerSchema = json.parse(partnerSchemaJson/*, secure*/);
	var mixedSchema = json.parse(mixedSchemaJson/*, secure*/);
	var typeOrNullSchema = json.parse(typeOrNullSchemaJson/*, secure*/);

	function validateInternal(data, schema) {
		return validate._validate(data, schema, {
			filter : true,
			existingOnly : false
		});
	}

	function log(result, data) {
		console.log("after: ", data);
		if (!result.valid) {
			array.forEach(result.errors, function(e) {
				console.log(e.property, ": ", e.message);
			});
		}
		console.log("-----------------------------");
	}

	function testErrors(expectedErrors, errors) {
		doh.assertEqual(expectedErrors.length, errors.length);
		array.forEach(expectedErrors, function(expErr, index) {
			doh.assertEqual(expErr.property, errors[index].property);
			doh.assertEqual(expErr.message, errors[index].message);
		});
	}

	function validateDetail(data) {
		console.log("before: ", data);
		var r = validateInternal(data, detailSchema);
		log(r, data);
		doh.t(r.valid, "validation was not successful");
	}

	//TODO:add other validation tests
	var testObject = {
		testUnion : function() {
			//this data is valid according to second type from the schema
			var data = {
				foo : "bar"
			};
			validateDetail(data);
		},
		testDefault : function() {
			//this data is valid according to second type from the schema
			//default version should be added
			var data = {
				foo : "bar"
			};
			validateDetail(data);
			doh.t((data.version == 1), "default was not added");
		},
		testFilter : function() {
			//this data is valid according to first type from the schema
			//'dateBegin' should be filtered
			var data = {
				foo : "bar",
				dateBegin : "2011-10-10"
			};
			validateDetail(data);
			doh.t(!("foo" in data), "additional prop was not deleted");
		},
		partnerGet : function() {
			var r = validateInternal(partnerData, partnerSchema);
			log(r, partnerData);
			doh.t(r.valid, "validation was not successful");
		},
		"testAdditionalProperties - default" : function() {
			//default is {} , which  means any type
			var schema = {
				type : "object"
			};

			var data = {
				a : "string",
				b : 5
			};

			var r = validateInternal(data, schema);
			log(r, data);
			doh.t(r.valid, "validation was not successful");
		},
		"testAdditionalProperties - true" : function() {
			var schema = {
				type : "object",
				additionalProperties : true
			};

			var data = {
				a : "string",
				b : 5
			};

			var r = validateInternal(data, schema);
			log(r, data);
			doh.t(r.valid, "validation was not successful");
		},
		"testAdditionalProperties - defined" : function() {
			var schema = {
				type : "object",
				additionalProperties : {
					type : "string"
				}
			};

			var data = {
				a : "string",
				b : 5
			};

			var r = validateInternal(data, schema);
			log(r, data);
			doh.t(!r.valid, "validation was unexpectedly successful");
			doh.t(r.errors[0].message == "number value found, but a string is required");
		},
		testRequired : function() {
			var schema = {
				type : "object",
				properties : {
					a : {
						type : "object",
						properties : {
							b : {
								type : "string",
								required : true
							}
						}
					},
					c : {
						type : "string",
						required : true
					}
				}
			};

			doh.assertTrue(validate._validate({
				c : "c"
			}, schema).valid, "#1 valid expected");

			doh.assertTrue(validate._validate({
				a : null,
				c : "c"
			}, schema).valid, "#2 valid expected");

			doh.assertTrue(validate._validate({
				a : undefined,
				c : "c"
			}, schema).valid, "#3 valid expected");

			doh.assertFalse(validate._validate({
				a : null
			}, schema).valid, "#4 invalid expected");

			doh.assertFalse(validate._validate({
				a : {},
				c : "a"
			}, schema).valid, "#5 invalid expected");
		},
		testCyclicSchema : function() {
			var schema = {
				type : "object",
				additionalProperties : false,
				properties : {}
			};

			schema.properties.a = {
				type : schema
			};

			doh.assertTrue(validate._validate({
				a : {
					a : {}
				}
			}, schema).valid, "#1 valid expected");
		},
		testMixedSchemaType : function() {
			var data = [
				{
					foo : "bar",
					foo2 : "bar2"
				}
			];
			validateInternal(data, mixedSchema);

			doh.t(data instanceof Array);
			doh.t("foo" in data[0], "foo should be present");
			doh.f("foo2" in data[0], "foo2 should be filtered out");

			data = {
				bar : "foo",
				bar2 : "foo2"
			};
			validateInternal(data, mixedSchema);

			doh.t("bar" in data, "bar should be present");
			doh.f("bar2" in data, "bar2 should be filtered out");
		},
		typeOrNull : function() {
			// === STRING OR NULL === 
			var data = {
				s1 : null,
				s2 : "1234567890",
				s3 : "123" //invalid
			};
			var res = validateInternal(data, typeOrNullSchema);

			doh.t(res.errors && res.errors.length == 1, "validation result should have 1 error");
			var err = res.errors[0];
			doh.t(err.message == "must be at least 5 characters long", "unexpected message: " + err.message);
			doh.t(err.property == "s3", "unexpected property: " + err.property);

			// === OBJECT OR NULL === 
			data = {
				o1 : null,
				o2 : {
					foo : 1,
					bar : 2
				//should be filtered
				},
				o3 : {//invalid - missing required field 'foo'
					bar : 2
				}
			};
			res = validateInternal(data, typeOrNullSchema);

			doh.t(res.errors && res.errors.length == 1, "validation result should have 1 error");
			err = res.errors[0];
			doh.t(err.message == "is missing and it is required", "unexpected message: " + err.message);
			doh.t(err.property == "o3.foo", "unexpected property: " + err.property);

			// === ARRAY OR NULL === 
			data = {
				a1 : null,
				a2 : [
					1,
					2
				],
				a3 : [//invalid - minItems is 2
					1
				]
			};
			res = validateInternal(data, typeOrNullSchema);
			doh.t(res.errors && res.errors.length == 1, "validation result should have 1 error");
			err = res.errors[0];
			doh.t(err.message == "There must be a minimum of 2 in the array", "unexpected message: " + err.message);
			doh.t(err.property == "a3", "unexpected property: " + err.property);
		}
	};

	function validateBasic(data) {
		console.log("before: ", data);
		var r = validateInternal(data, basicSchema);
		log(r, data);
		doh.t(r.valid, "validation was not successful");
	}

	var isValidTest = {
		testType : function() {
			// test basic validation types 
			var data = {
				intVal : 123,
				nullVal : null,
				stringVal : "123",
				numVal : 987.123,
				stringOrNull : "321",
				stringOrNull2 : null
			};
			validateBasic(data);
		},
		testString : function() {
			// test basic validation types
			var data = {
				stringVal : "123",
				stringOrNull : ""
			};
			validateBasic(data);
		},
		testDate : function() {
			// test date, should be convert to string Y-m-d
			var data = {
				dateVal : "2013-01-01",
				dateObjVal : new Date(),
				dateObjOrNull : null
			};
			validateBasic(data);
		},
		testTime : function() {
			// test date, should be convert to string hh:mm:ss
			var data = {
				timeObjVal : new Date(),
				timeObjOrNull : null
			};
			validateBasic(data);
		},
		testDateTime : function() {
			// test date-time, should be convert to ISO string
			var data = {
				dateTimeObjVal : new Date(),
				dateTimeObjOrNull : null
			};
			validateBasic(data);
		},
		testDateFormat : function() {
			var date = new Date();
			var data = {
				dateObjVal : stamp.toISOString(date, {
					zulu : false,
					selector : "date"
				}),
				timeObjVal : stamp.toISOString(date, { // TODO: format: T00:00:00 ?
					zulu : false,
					selector : "time"
				}),
				dateTimeObjVal : stamp.toISOString(date, {
					zulu : false
				})
			};
			validateBasic(data);
		},
		testFormatObj : function() {
			var date = new Date();
			var data = {
				dateObjVal : date,
				timeObjVal : date,
				dateTimeObjVal : date
			};
			validateBasic(data);
		},
		testFormatString : function() {
			var data = {
				dateObjVal : "2013-01-01",
				timeObjVal : "T01:30:00",
				dateTimeObjVal : "2013-01-01T01:30:00"
			};
			validateBasic(data);
		}
	};

	function validateBasicError(data, errors) {
		console.log("before: ", data);
		var r = validateInternal(data, basicSchema);
		log(r, data);
		doh.t(!r.valid, "validation was successful");
		testErrors(errors, r.errors);
	}

	var isInvalidTest = {
		testNull : function() {
			var data = {
				intVal : null,
				stringVal : null,
				numVal : null,
				dateVal : null,
				dateObjVal : null,
				timeObjVal : null,
				dateTimeObjVal : null
			};
			validateBasicError(data, [
				{
					property : "intVal",
					message : "object value found, but a integer is required"
				},
				{
					property : "stringVal",
					message : "object value found, but a string is required"
				},
				{
					property : "numVal",
					message : "object value found, but a number is required"
				},
				{
					property : "dateVal",
					message : "object value found, but a string is required"
				},
				{
					property : "dateObjVal",
					message : "object value found, but a string is required"
				},
				{
					property : "timeObjVal",
					message : "object value found, but a string is required"
				},
				{
					property : "dateTimeObjVal",
					message : "object value found, but a string is required"
				}
			]);
		},
		testType : function() {
			// test basic validation errors
			var data = {
				intVal : 123.125,
				nullVal : "foo",
				stringVal : 125,
				numVal : "987",
				stringOrNull : 321,
				stringOrNull2 : new Date()
			};
			validateBasicError(data, [
				{
					property : "intVal",
					message : "number value found, but a integer is required"
				},
				{
					property : "nullVal",
					message : "string value found, but a null is required"
				},
				{
					property : "stringVal",
					message : "number value found, but a string is required"
				},
				{
					property : "numVal",
					message : "string value found, but a number is required"
				},
				{
					property : "stringOrNull",
					message : "number value found, but a null is required"
				},
				{
					property : "stringOrNull2",
					message : "object value found, but a null is required"
				}
			]);
		},
		testString : function() {
			// test basic validation types
			var data = {
				stringVal : ""
			};
			validateBasicError(data, [
				{
					property : "stringVal",
					message : "object value found, but a string is required"
				}
			]);
		},
		dateFormat : function() {
			var data = {
				dateVal : "p",
				dateObjVal : "p",
				dateObjOrNull : "p",
				timeObjVal : "p",
				timeObjOrNull : "p",
				dateTimeObjVal : "p",
				dateTimeObjOrNull : "p"
			};
			validateBasicError(data, [
				{
					property : "dateVal",
					message : "p value found, but date format is required"
				},
				{
					property : "dateObjVal",
					message : "p value found, but date format is required"
				},
				{
					property : "dateObjOrNull",
					message : "p value found, but date format is required"
				},
				{
					property : "timeObjVal",
					message : "p value found, but time format is required"
				},
				{
					property : "timeObjOrNull",
					message : "p value found, but time format is required"
				},
				{
					property : "dateTimeObjVal",
					message : "p value found, but date-time format is required"
				},
				{
					property : "dateTimeObjOrNull",
					message : "p value found, but date-time format is required"
				}
			]);
		}
	};
	var v3SchemaUrl = Uri.resolve(null, require.toUrl("json/json-schema/draft-03/schema.json"));
	var v3SchemaReady = jsonRefXhr.get(v3SchemaUrl);

	function _testSchemaValidityAgainstV3(schema) {
		return function() {
			return v3SchemaReady//
			.then(function(v3Schema) {
				var result = validate._validate(schema, v3Schema);
				var validationErrMessage = result.errors && result.errors[0] && (result.errors[0].property + ": " + result.errors[0].message);

				doh.t(result.valid, validationErrMessage);
			});
		};
	}

	var sampleSchemaValidationTest = {
		"circular schema" : function() {
			return v3SchemaReady//
			.then(function(v3Schema) {
				doh.t(v3Schema === v3Schema.properties.additionalProperties.type[0], "Should by circular reference");
				doh.assertEqual("boolean", v3Schema.properties.additionalProperties.type[1]);
			});

		},
		"basic schema" : _testSchemaValidityAgainstV3(basicSchema),
		"detail schema" : _testSchemaValidityAgainstV3(detailSchema),
		"partner schema" : _testSchemaValidityAgainstV3(partnerSchema),
		"mixed schema" : _testSchemaValidityAgainstV3(mixedSchema),
		"type or null schema" : _testSchemaValidityAgainstV3(typeOrNullSchema)
	};

	var isValidSchemaTest = {
		"minimal valid schema" : function() {
			return v3SchemaReady//
			.then(function(v3Schema) {
				var schemaSample = {
					type : "object",
					properties : {}
				};

				var result = validate._validate(schemaSample, v3Schema);
				doh.t(result.valid, "Schema validation was not successfull");
			});
		}
	};

	var isInvalidSchemaTest = {
		"minimal invalid schema" : function() {
			return v3SchemaReady//
			.then(function(v3Schema) {
				var emptySchema = {
				// is empty schema valid?
				};

				var result = validate._validate(emptySchema, v3Schema);
				doh.t(result.valid, "Empty schema validation was not successfull");
			});

		},
		"required should be boolean" : function() {
			return v3SchemaReady//
			.then(function(v3Schema) {
				var schemaSample = {
					"type" : "object",
					"properties" : {
						"a" : {
							"type" : "string",
							"required" : "non boolean"
						}
					}
				};
				var result = validate._validate(schemaSample, v3Schema);
				doh.f(result.valid, "Schema validation was unexpectly successfull");
				doh.is("string value found, but a boolean is required", result.errors[0].message);
			});
		}
	};

	// --------------------------------------
	doh.register("validate-schema-samples", sampleSchemaValidationTest);
	doh.register("validate", testObject);
	doh.register("valid", isValidTest);
	doh.register("invalid", isInvalidTest);
	doh.register("valid-schema", isValidSchemaTest);
	doh.register("invalid-schema", isInvalidSchemaTest);

	ready(function() {
		doh.run();
	});
});