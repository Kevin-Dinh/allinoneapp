/**
 * created 12/13/2012
 * 
 * @author mbeliansky,jukrop
 * @see http://livedocs.dojotoolkit.org/util/doh
 * @description unit test for module "gjax/_base/date"
 * 
 * @generated by TemplateWizard, v.2012/11/21 //do not remove this comment please
 */
define([
	"doh",
	"dojo/has",
	"dojo/_base/array",
	"dojo/date/stamp",
	//tested libraries
	"gjax/_base/date"
], function(doh, has, array, dstamp, gdate) {

	function reverseOp(op) {
		// -1 -> 1; 0 -> 0; 1 -> -1 
		return op === 0 ? 0 : op < 0 ? 1 : -1;
	}
	
	function cond(op, a) {
		return op < 0 ? a < 0 : (op > 0 ? a > 0 : a === 0);
	}

	function assertEquals(expected, date1, date2, portion) {
		doh.is(expected, gdate.equals(date1, date2, portion), //
		"Error equaling dates: [" + date1 + ", " + date2 + "] " + portion);
		doh.is(expected, gdate.equals(date2, date1, portion), // commutative
		"Error equaling dates: [" + date2 + ", " + date1 + "] " + portion);
	}

	function assertCompare(op, date1, date2, portion) {
		// op:
		// -1 means result should be < 0
		//  0 means result should be == 0
		//  1 means result should be > 0
		
		doh.t(cond(op, gdate.compare(date1, date2, portion)), //
		"Error comparing dates: [" + date1 + ", " + date2 + "] " + portion);
		doh.t(cond(reverseOp(op), gdate.compare(date2, date1, portion)), //
		"Error comparing dates: [" + date2 + ", " + date1 + "] " + portion);
	}
	
	function assertGreatest(expected, date1, date2, portion) {
		doh.is(expected, gdate.greatest(date1, date2, portion), //
				"Error greatest date: [" + date1 + ", " + date2 + "] " + portion);
		doh.is(expected, gdate.greatest(date1, date2, portion), //
				"Error greatest return same instance: [" + date1 + ", " + date2 + "] " + portion);
		doh.is(typeof expected, typeof gdate.greatest(date1, date2, portion), //
				"Error greatest return type: [" + date1 + ", " + date2 + "] " + portion);
	}

	// DO NOT format this file please
	
	var date1String = "2013-07-15T12:30:00.000+02:00", date1 = dstamp.fromISOString(date1String);
	
	var compareDateTimeData = [
	    // date2, portion, op (first param (date1) is constant, see assertCompare for details on 'op')
		["2013-07-14", undefined, 1],
		["2013-07-15T08:00:00", undefined, 1],
		["2013-07-15T12:30:00", undefined, 0],
		["2013-07-15T19:40:00", undefined, -1],
		["2013-07-16", undefined, -1],
		// same with date objects
		[new Date(2013, 6, 14), undefined, 1],
		[new Date(2013, 6, 15, 8, 0), undefined, 1],
		[new Date(2013, 6, 15, 12, 30), undefined, 0],
		[new Date(2013, 6, 15, 19, 40), undefined, -1],
		[new Date(2013, 6, 16), undefined, -1]
	], compareDateData = [
		["2013-07-14", "date", 1],
		["2013-07-15T08:00:00", "date", 0],
		["2013-07-15T12:30:00", "date", 0],
		["2013-07-15T19:40:00", "date", 0],
		["2013-07-16", "date", -1],
		[new Date(2013, 6, 14), "date", 1],
		[new Date(2013, 6, 15, 8, 0), "date", 0],
		[new Date(2013, 6, 15, 12, 30), "date", 0],
		[new Date(2013, 6, 15, 19, 40), "date", 0],
		[new Date(2013, 6, 16), "date", -1]
	], compareTimeData = [
		["2013-07-14", "time", 1],
		["2013-07-14T08:00:00", "time", 1],
		["2013-07-14T12:30:00", "time", 0],
		["2013-07-14T19:40:00", "time", -1],
		["2013-07-16", "time", 1],
		["2013-07-16T08:00:00", "time", 1],
		["2013-07-16T12:30:00", "time", 0],
		["2013-07-16T19:40:00", "time", -1],
		[new Date(2013, 6, 14), "time", 1],
		[new Date(2013, 6, 14, 8, 0), "time", 1],
		[new Date(2013, 6, 14, 12, 30), "time", 0],
		[new Date(2013, 6, 14, 19, 40), "time", -1],
		[new Date(2013, 6, 16), "time", 1],
		[new Date(2013, 6, 16, 8, 0), "time", 1],
		[new Date(2013, 6, 16, 12, 30), "time", 0],
		[new Date(2013, 6, 16, 19, 40), "time", -1]
	], compareFormattedData = [
  		["2013-07-14", "dd.MM.", 1],
  		["2019-07-15T08:00:00", "dd.MM.", 0],
  		["2080-09-15T12:30:00", "dd", 0],
  		["2013-11-15", "MM.", -1], // "07." < "11."
  		["2013-11-15", "M.", 1] // "7." > "11."
  		// TODO more format tests
	], compareStrangeData = [
		["2013-07-15T08:00:00", "foobar", 1],
		["2013-07-15T12:30:00", "foobar", 0],
		["2013-07-15T19:40:00", "foobar", -1],
		["2013-07-15T08:00:00", "", 1],
		["2013-07-15T12:30:00", "", 0],
		["2013-07-15T19:40:00", "", -1],
		["2013-07-15T08:00:00", " ", 1],
		["2013-07-15T12:30:00", " ", 0],
		["2013-07-15T19:40:00", " ", -1]
// "foobar" -> gjax/_base/date create null -> dojo/date create new Date() from null
//		["foobar", undefined, -1],
//		["foobar", "date", -1],
//		["foobar", "time", 1],
//		["foobar", "foobar", -1]
// 0 caused to create new Date(), see dojo/date#96, gjax/_base/date copy this behaviour 
//		[0, undefined, -1],
//		[0, "date", -1],
//		[0, "time", 1],
//		[0, "foobar", -1]
	], equalsData = [
	    // date2, portion, result	(first param (date1) is constant)
		["2013-07-15T12:30:00", undefined, true],
		["2013-07-15", "date", true],
		["2013-11-15T12:30:00", "time", true],
		["2013-07-15T12:30:00", "foobar", true],
		["foobar", undefined, false],
		[0, undefined, false],
		[null, undefined, false],
		[undefined, undefined, false]
	], greatestDate = [
		["2013-07-15", "2013-07-16", 1],
		[new Date(2013, 6, 15), new Date(2013, 6, 16), 1],
		["2013-07-15", new Date(2013, 6, 16), 1],
		["2013-07-15", "", 0],
		["2013-07-15", null, 0],
		["", "2013-07-16", 1],
		[null, "2013-07-16", 1],
		[new Date(2013, 6, 15), "", 0],
		[new Date(2013, 6, 15), null, 0],
		["", new Date(2013, 6, 16), 1],
		[null, new Date(2013, 6, 16), 1]
	], greatestTime = [
		["2013-07-15T16:00:00", "2013-07-16T08:00:00", 0],
		[new Date(2013, 6, 15, 16, 0, 0), new Date(2013, 6, 16, 8, 0, 0), 0],
		["2013-07-15T16:00:00", new Date(2013, 6, 16, 8, 0, 0), 0]
	], greatestDateTime = [
		["2013-07-15T16:00:00", "2013-07-16T08:00:00", 1],
		[new Date(2013, 6, 15, 16, 0, 0), new Date(2013, 6, 16, 8, 0, 0), 1],
		["2013-07-15T16:00:00", new Date(2013, 6, 16, 8, 0, 0), 1]
	], greatestOther = [
		["2013-08-15T16:00:00", "2013-07-16T08:00:00", "MM.dd.", 0],
		[new Date(2013, 7, 15, 16, 0, 0), new Date(2013, 6, 16, 8, 0, 0), "MM.dd.", 0],
		["2013-08-15T16:00:00", new Date(2013, 6, 16, 8, 0, 0), "MM.dd.", 0]
	],
	inRangeData = [
	    // start, end, result	(first param (date) is constant)
		["2013-07-14", null, true],
		["2013-07-15", null, true],
		["2013-07-16", null, false],
		["2013-07-16", "2013-07-16", false],
		["2013-07-15", "2013-07-16", true],
		["2013-07-14", "2013-07-16", true],
		["2013-07-14", "2013-07-15", true],
		["2013-07-15", "2013-07-15", true],
		["2013-07-14", "2013-07-14", false],
		[new Date(2013, 6, 14), null, true],
		[new Date(2013, 6, 16), null, false],
		[new Date(2013, 6, 15), new Date(2013, 6, 16), true],
		[new Date(2013, 6, 14), new Date(2013, 6, 16), true],
		[new Date(2013, 6, 14), new Date(2013, 6, 14), false]
	], differenceData = [
 	    // date2, interval	(first param (date1) is constant)
		["2013-07-14", undefined, -2/*because of rounding*/],
		["2013-07-15T08:00:00", undefined, 0],
		["2013-07-15T12:30:00", undefined, 0],
		["2013-07-15T19:40:00", undefined, 0],
		["2013-07-15T19:40:00", "hour", 7],
		["2013-07-17", undefined, 1/*because of rounding*/],
		// same with date objects
		[new Date(2013, 6, 14), undefined, -2],
		[new Date(2013, 6, 15, 8, 0), undefined, 0],
		[new Date(2013, 6, 15, 12, 30), undefined, 0],
		[new Date(2013, 6, 15, 19, 40), undefined, 0],
		[new Date(2013, 6, 15, 19, 40), "hour", 7],
		[new Date(2013, 6, 17), undefined, 1]
	];
	
	var testObject = {
		isDate_date : function() {
			array.map([
				new Date(),
				new Date(2012, 0, 1),
				new Date(123456789)
			], doTest);
			function doTest(d) {
				doh.t(gdate.isDate(d));
			}
		},
		isDate_noDate : function() {
			array.map([
				new Date("xxx"), // invalid date is NOT considered date (since 2012/12/14) !       
				Date(), // Date() return string
				{}, // object is not a date, but date is an object
				"2012-01-01",
				Infinity,
				0,
				NaN,
				"im a teapot"
			], doTest);
			function doTest(d) {
				doh.f(gdate.isDate(d));
			}
		},
		today : function() {
			var t = new Date();
			t.setHours(0, 0, 0, 0); // reset time
			doh.is(t, gdate.today());
		},
		equals : function() {
			array.forEach(equalsData, function(row) {
				var date2 = row[0], portion = row[1], expected = row[2];
				assertEquals(expected, date1, date2, portion);
				assertEquals(expected, date1String, date2, portion);
			});
			// null dates are not converted to current date
			doh.is(false, gdate.equals(new Date(), null, "date"), "Error equaling current date and null");
			doh.is(true, gdate.equals(null, null, "date"), "Error equaling nulls");
		},
		compare_date : function() {
			array.forEach(compareDateData, function(row) {
				var date2 = row[0], portion = row[1], op = row[2];
				assertCompare(op, date1, date2, portion);
				assertCompare(op, date1String, date2, portion);
	      	});
		},
		compare_time : function() {
			array.forEach(compareTimeData, function(row) {
				var date2 = row[0], portion = row[1], op = row[2];
				assertCompare(op, date1, date2, portion);
				assertCompare(op, date1String, date2, portion);
			});
		},
		compare_datetime : function() {
			array.forEach(compareDateTimeData, function(row) {
				var date2 = row[0], portion = row[1], op = row[2];
				assertCompare(op, date1, date2, portion);
				assertCompare(op, date1String, date2, portion);
			});
		},
		compare_with_formats : function() {
			array.forEach(compareFormattedData, function(row) {
				var date2 = row[0], format = row[1], op = row[2];
				assertCompare(op, date1, date2, format);
				assertCompare(op, date1String, date2, format);
			});
		},
		compare_other : function() {
			array.forEach(compareStrangeData, function(row) {
				var date2 = row[0], portion = row[1], op = row[2];
				assertCompare(op, date1, date2, portion);
				assertCompare(op, date1String, date2, portion);
			});
			doh.t(gdate.compare("abc", "def") < 0);
			doh.t(gdate.compare("def", "abc") < 0);
		},
		greatest_date : function(){
			array.forEach(greatestDate, function(row) {
				assertGreatest(row[row[2]], row[0], row[1], "date");
			});
		},
		greatest_time : function(){
			array.forEach(greatestTime, function(row) {
				assertGreatest(row[row[2]], row[0], row[1], "time");
			});
		},
		greatest_dateTime : function(){
			array.forEach(greatestDateTime, function(row) {
				assertGreatest(row[row[2]], row[0], row[1], "datetime");
			});
		},
		greatest_other : function(){
			array.forEach(greatestOther, function(row) {
				assertGreatest(row[row[3]], row[0], row[1], row[2]);
			});
		},
		inRange_date : function() {
			var portion = "date";
			array.forEach(inRangeData, function(row) {
				var start = row[0], end = row[1], expected = row[2];
				doh.is(expected, gdate.inRange(date1, start, end, portion), //
						"Error inRange dates: [" + start + ", " + end + "] " + portion);
				doh.is(expected, gdate.inRange(date1String, start, end, portion), //
						"Error inRange dates: [" + start + ", " + end + "] " + portion);
			});
		},
		difference_date : function() {
			array.forEach(differenceData, function(row) {
				var date2 = row[0], interval = row[1], expected = row[2];
				doh.is(expected, gdate.difference(date1, date2, interval));
				doh.is(expected, gdate.difference(date1String, date2, interval));
			});
		}
	};

	doh.register("gjax/_base/date", testObject);
	
	// runnable with: node (dnode)
	has("host-browser") || doh.run();
});
